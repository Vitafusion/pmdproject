data(iris)
View(iris)
data(iris)
##################################################### calculate P matrix
cal_pmatrix = function(parm, x_mat, row_num, category_number){
n = nrow(x_mat)
m = category_number
parm = matrix(parm,n,m)
P = matrix(0, nrow = n, ncol = category_number)
for (i in 1:n) {
for (j in 1:m) {
#browser()
P[i,j] = exp(parm[j,]%*%t(x[i,]))/ sum(exp(parm%*%t(x[i,])))
}
}
return(P)
}
########################################### optimize likelihood
parm=rep(0.1,4*3) #3 categories, 4 covariates
x_mat = data("iris3")
x_mat = data("iris3")
data(iris)
set.seed(7)
x_mat = data("iris3")
data("iris3")
data(iris3)
x_mat = iris[,1:4]
n = ncol(x_mat)
###################################### Creating groups
category_number = 3
n = ncol(x_mat)
m = category_number
parm = matrix(parm,n,m)
parm
P = matrix(0, nrow = n, ncol = category_number)
P
for (i in 1:n) {
for (j in 1:m) {
#browser()
P[i,j] = exp(parm[j,]%*%t(x[i,]))/ sum(exp(parm%*%t(x[i,])))
}
}
for (i in 1:n) {
for (j in 1:m) {
#browser()
P[i,j] = exp(parm[j,]%*%t(x_mat[i,]))/ sum(exp(parm%*%t(x_mat[i,])))
}
}
parm = matrix(parm,n,m)
parm
parm[j,]%*%t(x_mat[i,])
parm[j,]
t(x_mat[i,])
x_mat[i,]%*%parm[,j]
parm[,j]
x_mat[i,]%*%t(parm[,j])
x_mat[i,]
t(parm[,j])
x_mat = as.matrix(iris[,1:4])
n = ncol(x_mat)
m = category_number
parm = matrix(parm,n,m)
P = matrix(0, nrow = n, ncol = category_number)
x_mat[i,]%*%t(parm[,j])
x_mat[i,]%*%(parm[,j])
parm%*%t(x_mat[i,])
x_mat[i,]%*%parm[,j]
x_mat[i,]%*%parm
sum(exp(x_mat[i,]%*%parm))
exp(x_mat[i,]%*%(parm[,j]))/ sum(exp(x_mat[i,]%*%parm))
n = ncol(x_mat)
m = category_number
parm = matrix(parm,n,m)
parm
P = matrix(0, nrow = n, ncol = category_number)
P
n = ncol(x_mat)
m = category_number
parm = matrix(parm,n,m)
P = matrix(0, nrow = nrow(x_mat), ncol = category_number)
P
for (i in 1:n) {
for (j in 1:m) {
#browser()
P[i,j] = exp(x_mat[i,]%*%(parm[,j]))/ sum(exp(x_mat[i,]%*%parm))
}
}
P
for (i in 1:nrow(x_mat)) {
for (j in 1:m) {
#browser()
P[i,j] = exp(x_mat[i,]%*%(parm[,j]))/ sum(exp(x_mat[i,]%*%parm))
}
}
P
make.data.equal.groups = function(dat, groups_number,category_name=c("setosa","versicolor","virginica"),categor_column = 'Species'){
n = nrow(dat)
group = list()
if(n %% groups_number != 0)
stop("invalid number for grouping.")
out = matrix(NA,nrow = groups_number,ncol = length(category_name))
ss <- sample(1:groups_number,size=n,replace=TRUE,prob=rep(1/groups_number,groups_number))
for (i in 1:groups_number) {
group[[i]] = dat[ss==i,]
expr = paste(categor_column)
out[i,1] = nrow(group[[i]][which(group[[i]][,expr]==category_name[1]),])
out[i,2] = nrow(group[[i]][which(group[[i]][,expr]==category_name[2]),])
out[i,3] = nrow(group[[i]][which(group[[i]][,expr]==category_name[3]),])
}
return(list(group,out))
}
compute_l.vec = function(result){
m = length(result)
res = result[1:(m-1)]
l.vec = rep(0,m-1)
for (i in 1:(m-1)) {
l.vec[i] = as.numeric(res[i]) + 1
}
return(l.vec)
}
l.vec.compute=function(k, cn.vec, m)
{
k=k-1
l.vec=rep(0, m-1)
for(i in 1:(m-1))
{
aa=k%%cn.vec[i]
bb=(k-aa)/cn.vec[i]
l.vec[i]=bb
k=aa
}
l.vec=l.vec+1
return(l.vec)
}
pmatrix <- function(n,m){
p <- matrix(0,nrow = n,ncol = m,byrow = T)
for (i in 1:n) {
r <- runif(m)
r <- r/sum(r) #generate row
p[i,] <- r
}
return(p)
}
res = make.data.equal.groups(iris,10)
res
groups = res[[1]]
groups
count_result = res[[2]]
count_result
